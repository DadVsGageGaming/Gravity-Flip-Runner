<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Space Runner 3D</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    background: #000010;
    overflow: hidden;
    user-select: none;
    touch-action: none;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  #score {
    position: absolute;
    top: 15px;
    left: 15px;
    color: #00fff7;
    font-weight: 700;
    font-size: 24px;
    text-shadow: 0 0 8px #00fff7;
    user-select: none;
    z-index: 20;
  }
  #startScreen, #gameOverScreen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    color: #00fff7;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 28px;
    font-weight: 700;
    z-index: 30;
    user-select: none;
  }
  button {
    margin-top: 20px;
    padding: 14px 36px;
    font-size: 22px;
    font-weight: 700;
    background: #00fff7;
    border: none;
    border-radius: 14px;
    cursor: pointer;
    color: #000011;
    box-shadow: 0 0 18px #00fff7;
    transition: background 0.3s ease;
  }
  button:hover {
    background: #33ffff;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>

<div id="startScreen">
  Space Runner 3D<br />
  <button id="startBtn">Start Game</button>
  <small style="margin-top:12px; font-weight:400; font-size:14px; color:#00fff7aa;">
    Use arrow keys or swipe left/right to move, up arrow or tap to jump
  </small>
</div>

<div id="gameOverScreen" style="display:none;">
  Game Over!<br />
  <div id="finalScore"></div>
  <button id="restartBtn">Play Again</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
<script>
  let scene, camera, renderer;
  let player, playerVelocityY = 0;
  let platforms = [];
  const laneCount = 3;
  const laneWidth = 4;
  let currentLane = 1; // 0-left,1-center,2-right
  let isJumping = false;

  let forwardSpeed = 0.15;
  let gravity = 0.02;
  let jumpForce = 0.5;

  let score = 0;
  let scoreDisplay = document.getElementById('score');

  let gameRunning = false;

  let clock = new THREE.Clock();

  const platformLength = 10;
  const platformWidth = laneWidth * laneCount;
  const platformHeight = 1;

  const platformGapChance = 0.3; // chance to have a gap in lane per platform

  const platformsToKeep = 15;

  const startScreen = document.getElementById('startScreen');
  const startBtn = document.getElementById('startBtn');
  const gameOverScreen = document.getElementById('gameOverScreen');
  const finalScore = document.getElementById('finalScore');
  const restartBtn = document.getElementById('restartBtn');

  // Initialize Three.js scene
  function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000010, 0.07);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);
    camera.lookAt(0, 0, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000010);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0x00fff7, 2, 50);
    pointLight.position.set(0, 10, 10);
    scene.add(pointLight);

    // Player - glowing cube
    const playerGeometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
    const playerMaterial = new THREE.MeshStandardMaterial({
      color: 0x00fff7,
      emissive: 0x00fff7,
      emissiveIntensity: 1,
      metalness: 0.8,
      roughness: 0.2
    });
    player = new THREE.Mesh(playerGeometry, playerMaterial);
    player.position.set(0, 1, 0);
    scene.add(player);

    // Create initial platforms
    for (let i = 0; i < platformsToKeep; i++) {
      addPlatform(i * platformLength);
    }

    // Add neon tunnel effect - rings
    for (let i = 0; i < 40; i++) {
      let ringGeometry = new THREE.TorusGeometry(7, 0.1, 16, 100);
      let ringMaterial = new THREE.MeshBasicMaterial({ color: 0x00fff7, transparent: true, opacity: 0.1 });
      let ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.position.z = -i * 3;
      scene.add(ring);
    }

    window.addEventListener('resize', onWindowResize, false);
    window.addEventListener('keydown', onKeyDown, false);
    window.addEventListener('keyup', onKeyUp, false);
    initTouchControls();
  }

  // Platform class
  class Platform {
    constructor(zPos) {
      this.group = new THREE.Group();
      this.z = zPos;

      this.lanes = [];
      for (let lane = 0; lane < laneCount; lane++) {
        if (Math.random() < platformGapChance) {
          // gap - skip creating platform for this lane
          this.lanes.push(null);
          continue;
        }
        let geometry = new THREE.BoxGeometry(laneWidth, platformHeight, platformLength);
        let material = new THREE.MeshStandardMaterial({
          color: 0x002f3e,
          emissive: 0x004d66,
          emissiveIntensity: 0.8,
          metalness: 0.5,
          roughness: 0.4
        });
        let block = new THREE.Mesh(geometry, material);
        block.position.set((lane - 1) * laneWidth, 0, zPos);
        this.group.add(block);
        this.lanes.push(block);
      }
      scene.add(this.group);
    }

    move(dz) {
      this.group.position.z += dz;
      this.z += dz;
    }

    dispose() {
      this.lanes.forEach(block => {
        if (block) {
          this.group.remove(block);
          block.geometry.dispose();
          block.material.dispose();
        }
      });
      scene.remove(this.group);
    }
  }

  let platformObjects = [];

  function addPlatform(zPos) {
    let p = new Platform(zPos);
    platformObjects.push(p);
  }

  function removePlatform(p) {
    p.dispose();
    platformObjects = platformObjects.filter(obj => obj !== p);
  }

  // Game variables
  let moveLeft = false;
  let moveRight = false;
  let jump = false;

  let jumpVelocity = 0;
  let isPlayerJumping = false;

  // Player lane position (0,1,2)
  function setPlayerLane(lane) {
    currentLane = Math.min(Math.max(lane, 0), laneCount - 1);
  }

  // Controls
  function onKeyDown(e) {
    if (!gameRunning) return;
    switch (e.code) {
      case 'ArrowLeft': moveLeft = true; break;
      case 'ArrowRight': moveRight = true; break;
      case 'ArrowUp':
      case 'Space': jump = true; break;
    }
  }

  function onKeyUp(e) {
    switch (e.code) {
      case 'ArrowLeft': moveLeft = false; break;
      case 'ArrowRight': moveRight = false; break;
      case 'ArrowUp':
      case 'Space': jump = false; break;
    }
  }

  // Touch controls (swipe left/right/up)
  let touchStartX = null;
  let touchStartY = null;
  function initTouchControls() {
    window.addEventListener('touchstart', e => {
      if (!gameRunning) return;
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });
    window.addEventListener('touchend', e => {
      if (!gameRunning) return;
      if (touchStartX === null || touchStartY === null) return;
      let dx = e.changedTouches[0].clientX - touchStartX;
      let dy = e.changedTouches[0].clientY - touchStartY;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 40) {
          // swipe right
          moveRight = true;
          moveLeft = false;
          setTimeout(() => moveRight = false, 100);
        } else if (dx < -40) {
          // swipe left
          moveLeft = true;
          moveRight = false;
          setTimeout(() => moveLeft = false, 100);
        }
      } else {
        if (dy < -40) {
          // swipe up
          jump = true;
          setTimeout(() => jump = false, 150);
        }
      }

      touchStartX = null;
      touchStartY = null;
    });
  }

  // Game loop
  function animate() {
    if (!gameRunning) return;

    // Move platforms toward player
    platformObjects.forEach(p => p.move(forwardSpeed));

    // Remove platforms behind player and add new platforms
    if (platformObjects.length > 0) {
      if (platformObjects[0].z > 10) {
        removePlatform(platformObjects[0]);
        addPlatform(platformObjects[platformObjects.length - 1].z - platformLength);
      }
    }

    // Player lateral movement smooth
    let targetX = (currentLane - 1) * laneWidth;
    player.position.x += (targetX - player.position.x) * 0.2;

    // Player jump physics
    if (isPlayerJumping) {
      playerVelocityY -= gravity;
      player.position.y += playerVelocityY;

      if (player.position.y <= 1) {
        player.position.y = 1;
        isPlayerJumping = false;
        playerVelocityY = 0;
      }
    } else if (jump && !isPlayerJumping) {
      // start jump
      isPlayerJumping = true;
      playerVelocityY = jumpForce;
    }

    // Collision detection: Check if player is on platform or fell
    if (!isPlayerJumping) {
      // Check if there's platform under player lane at z=0
      let platformBelow = false;
      for (let p of platformObjects) {
        let localZ = p.z + p.group.position.z;
        if (localZ > -platformLength && localZ < platformLength) {
          let laneBlock = p.lanes[currentLane];
          if (laneBlock) {
            platformBelow = true;
            break;
          }
        }
      }
      if (!platformBelow) {
        // Player falls: game over
        endGame();
        return;
      }
    }

    // Increase score by distance
    score += forwardSpeed * 10;
    scoreDisplay.textContent = 'Score: ' + Math.floor(score);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  function startGame() {
    // Reset everything
    score = 0;
    scoreDisplay.textContent = 'Score: 0';
    gameRunning = true;

    // Reset player
    player.position.set(0, 1, 0);
    setPlayerLane(1);
    isPlayerJumping = false;
    playerVelocityY = 0;

    // Remove old platforms
    platformObjects.forEach(p => p.dispose());
    platformObjects = [];

    // Add new platforms
    for (let i = 0; i < platformsToKeep; i++) {
      addPlatform(-i * platformLength);
    }

    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';

    animate();
  }

  function endGame() {
    gameRunning = false;
    finalScore.textContent = 'Your Score: ' + Math.floor(score);
    gameOverScreen.style.display = 'flex';
  }

  startBtn.onclick = startGame;
  restartBtn.onclick = startGame;

  // Handle lane change on key press
  function updateLane() {
    if (moveLeft) {
      setPlayerLane(currentLane - 1);
      moveLeft = false;
    }
    if (moveRight) {
      setPlayerLane(currentLane + 1);
      moveRight = false;
    }
  }

  function gameUpdate() {
    if (!gameRunning) return;
    updateLane();
    setTimeout(gameUpdate, 100); // slow lane change update for smoothness
  }

  // Initialize everything and start update loop
  init();
  gameUpdate();

  // Resize handler
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }
</script>

</body>
</html>
